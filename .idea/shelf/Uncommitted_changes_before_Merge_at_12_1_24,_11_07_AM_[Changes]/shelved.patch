Index: mpc/core.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import List\nfrom mpc.party import Party, BeaverParty\nclass MPC:\n    '''\n    MPC class represents the Multi-Party Computation protocol.\n    base class for all the MPC operations\n    \n    attributes:\n        parties: list of parties in the computation\n\n    methods:\n        get_party(index): returns the party at the given index\n    '''\n    def __init__(self, parties: List[Party] | List[BeaverParty]) -> None:\n        self.parties = parties\n    \n    def get_party(self, index):\n        return self.parties[index]\n\nclass MPCAddition(MPC):\n    '''\n    Inherited MPC class for the addition operation\n    Gets a list of parties and computes the sum of the partial sums generated by each party\n\n    methods:\n        compute(): computes the sum of the shares\n    '''\n    def compute(self) -> int:\n        total_sum = sum([party.compute_partial_sum() for party in self.parties])\n\n        return total_sum % self.parties[-1].modulo\n \n\nclass MPCAverage(MPCAddition):\n    def compute(self) -> int:\n        return super().compute() / len(self.parties)\n\n \nclass MPCMultiplication(MPC):\n    '''\n    Inherited MPC class for the multiplication operation using Beaver's Triple\n    Each party computes the partial product of the shares and the final product is computed by summing the partial products\n    x*y = c + e*b + f*a + [e*f] where [] is computed by only one party\n\n    a, b, c are the shares of the Beaver's Triple\n    e,f are the partial values computed by each party [e = x - a, f = y - b]\n\n    Attributes:\n        e: partial value e\n        f: partial value f\n        product_shares: list of partial products computed by each party\n\n    Methods:\n        compute_ef_shares(): computes the partial values e and f (private method)\n        compute(): computes the product of the shares\n\n    '''\n    def __init__(self, parties: List[BeaverParty]) -> None:\n        super().__init__(parties)\n        self.e, self.f = None, None\n        self.product_shares = []\n\n    def compute_ef_shares(self) -> int:\n        e_shares, f_shares = [], []\n        for i, party in enumerate(self.parties):\n            e, f = party.compute_partial_e_f()\n            e_shares.append(e)\n            f_shares.append(f)\n\n        self.e = sum(e_shares) % self.parties[-1].modulo\n        self.f = sum(f_shares) % self.parties[-1].modulo\n\n    def compute(self):\n        \"\"\"\n        Computes the product of the shares using Beaver's Triple\n        x*y = c + e*b + f*a + [e*f]\n        sums the partial products computed by each party and last party computes the final product\n\n        Returns:\n            Int: the final product of the shares [x*y]\n        \"\"\"\n        self.compute_ef_shares()\n        for party in self.parties:\n            product = party.compute_partial_product(self.e, self.f)\n            self.product_shares.append(product)  \n        \n        final_product = sum(self.product_shares)\n        final_product = (final_product + (self.e * self.f)) % self.parties[-1].modulo\n\n        return final_product\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mpc/core.py b/mpc/core.py
--- a/mpc/core.py	(revision 59043ce1d8b682af9354c45934768577c55ae5d8)
+++ b/mpc/core.py	(date 1733031212686)
@@ -1,43 +1,48 @@
 from typing import List
 from mpc.party import Party, BeaverParty
+
+
 class MPC:
-    '''
+    """
     MPC class represents the Multi-Party Computation protocol.
     base class for all the MPC operations
-    
+
     attributes:
         parties: list of parties in the computation
 
     methods:
         get_party(index): returns the party at the given index
-    '''
+    """
+
     def __init__(self, parties: List[Party] | List[BeaverParty]) -> None:
         self.parties = parties
-    
+
     def get_party(self, index):
         return self.parties[index]
 
+
 class MPCAddition(MPC):
-    '''
+    """
     Inherited MPC class for the addition operation
     Gets a list of parties and computes the sum of the partial sums generated by each party
 
     methods:
         compute(): computes the sum of the shares
-    '''
+    """
+
     def compute(self) -> int:
         total_sum = sum([party.compute_partial_sum() for party in self.parties])
 
         return total_sum % self.parties[-1].modulo
- 
+
 
 class MPCAverage(MPCAddition):
     def compute(self) -> int:
         return super().compute() / len(self.parties)
 
- 
+
 class MPCMultiplication(MPC):
-    '''
+    """
     Inherited MPC class for the multiplication operation using Beaver's Triple
     Each party computes the partial product of the shares and the final product is computed by summing the partial products
     x*y = c + e*b + f*a + [e*f] where [] is computed by only one party
@@ -54,7 +59,8 @@
         compute_ef_shares(): computes the partial values e and f (private method)
         compute(): computes the product of the shares
 
-    '''
+    """
+
     def __init__(self, parties: List[BeaverParty]) -> None:
         super().__init__(parties)
         self.e, self.f = None, None
@@ -82,10 +88,9 @@
         self.compute_ef_shares()
         for party in self.parties:
             product = party.compute_partial_product(self.e, self.f)
-            self.product_shares.append(product)  
-        
+            self.product_shares.append(product)
+
         final_product = sum(self.product_shares)
         final_product = (final_product + (self.e * self.f)) % self.parties[-1].modulo
 
         return final_product
-
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from mpc.core import MPCAddition, MPCAverage\nfrom mpc.party import Party\nfrom mpc.utils import generate_secret_shares, sum_of_values\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\ndef main():\n    clients = int(input(\"Enter the number of participants: \"))\n    client_values = [int(input(f\"Enter the value for client {i+1}: \")) for i in range(clients)]\n    modulo = int(input(\"Enter the modulo: \"))\n    share_count = int(input(\"Enter the number of shares to be generated: \"))\n\n    client_shares = [generate_secret_shares(value, share_count, modulo) for value in client_values]\n    for client_share in client_shares:\n        logging.info(client_share)\n    client_shares_vertical = list(zip(*client_shares))\n    for client_share in client_shares_vertical:\n        logging.info(client_share)\n    parties = [Party(share, modulo) for share in client_shares_vertical]\n\n    mpc_addition = MPCAddition(parties)\n    mpc_average = MPCAverage(parties)\n\n    logging.info(f\"Actual sum: {sum_of_values(client_values)}\")\n    logging.info(f\"MPC computed sum: {mpc_addition.compute()}\")\n    logging.info(f'MPC Computed Average: {mpc_average.compute()}')\nif __name__ == \"__main__\":\n    main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 59043ce1d8b682af9354c45934768577c55ae5d8)
+++ b/main.py	(date 1733031212676)
@@ -5,9 +5,10 @@
 
 logging.basicConfig(level=logging.INFO)
 
+
 def main():
     clients = int(input("Enter the number of participants: "))
-    client_values = [int(input(f"Enter the value for client {i+1}: ")) for i in range(clients)]
+    client_values = [int(input(f"Enter the value for client {i + 1}: ")) for i in range(clients)]
     modulo = int(input("Enter the modulo: "))
     share_count = int(input("Enter the number of shares to be generated: "))
 
@@ -25,5 +26,7 @@
     logging.info(f"Actual sum: {sum_of_values(client_values)}")
     logging.info(f"MPC computed sum: {mpc_addition.compute()}")
     logging.info(f'MPC Computed Average: {mpc_average.compute()}')
+
+
 if __name__ == "__main__":
     main()
Index: mpc/protocols/ShamirSharing.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from mpc.protocols.ShamirPrep import generate_polynomial, evaluate_polynomial\nfrom config.constants import DEFAULT_PRIME, DEFAULT_THRESHOLD_DEGREE\n\ndef generate_shares(secret, num_shares, threshold_degree=DEFAULT_THRESHOLD_DEGREE, prime=DEFAULT_PRIME):\n    \"\"\"\n    Generate a list of shares for the given secret using Shamir's Secret Sharing.\n\n    Args:\n        secret (int): The secret to be shared.\n        num_shares (int): The number of shares to generate.\n        threshold_degree (int): The degree of the polynomial (k - 1, where k is the threshold).\n        prime (int): A prime number larger than the secret.\n\n    Returns:\n        list: A list of (x, y) tuples representing the shares.\n    \"\"\"\n    if secret >= prime:\n        raise ValueError(\"Secret must be less than the prime number.\")\n    if threshold_degree >= num_shares:\n        raise ValueError(\"Threshold degree must be less than the number of shares.\")\n    \n    polynomial = generate_polynomial(secret, threshold_degree, prime)\n    return [(i, evaluate_polynomial(polynomial, i, prime)) for i in range(1, num_shares + 1)]\n\ndef reconstruct_shares(shares, prime=DEFAULT_PRIME):\n    \"\"\"\n    Reconstruct the secret from a given list of shares using Lagrange interpolation.\n\n    Args:\n        shares (list): A list of (x, y) tuples representing the shares.\n        prime (int): A prime number for modular arithmetic.\n\n    Returns:\n        int: The reconstructed secret.\n    \"\"\"\n    total = 0\n\n    for i, (xj, yj) in enumerate(shares):\n        lagrange_coefficient = 1\n        for k, (xk, _) in enumerate(shares):\n            if i == k:\n                continue\n            lagrange_coefficient *= -xk * pow(xj - xk, -1, prime)\n            lagrange_coefficient %= prime\n        total += yj * lagrange_coefficient\n        total %= prime\n\n    return total\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mpc/protocols/ShamirSharing.py b/mpc/protocols/ShamirSharing.py
--- a/mpc/protocols/ShamirSharing.py	(revision 59043ce1d8b682af9354c45934768577c55ae5d8)
+++ b/mpc/protocols/ShamirSharing.py	(date 1733031302726)
@@ -1,6 +1,7 @@
 from mpc.protocols.ShamirPrep import generate_polynomial, evaluate_polynomial
 from config.constants import DEFAULT_PRIME, DEFAULT_THRESHOLD_DEGREE
 
+
 def generate_shares(secret, num_shares, threshold_degree=DEFAULT_THRESHOLD_DEGREE, prime=DEFAULT_PRIME):
     """
     Generate a list of shares for the given secret using Shamir's Secret Sharing.
@@ -18,10 +19,11 @@
         raise ValueError("Secret must be less than the prime number.")
     if threshold_degree >= num_shares:
         raise ValueError("Threshold degree must be less than the number of shares.")
-    
+
     polynomial = generate_polynomial(secret, threshold_degree, prime)
     return [(i, evaluate_polynomial(polynomial, i, prime)) for i in range(1, num_shares + 1)]
 
+
 def reconstruct_shares(shares, prime=DEFAULT_PRIME):
     """
     Reconstruct the secret from a given list of shares using Lagrange interpolation.
Index: mpc/protocols/ShamirPrep.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from secrets import randbelow\nfrom config.constants import DEFAULT_PRIME, DEFAULT_THRESHOLD_DEGREE\n\ndef generate_polynomial(secret, threshold_degree=DEFAULT_THRESHOLD_DEGREE, prime=DEFAULT_PRIME):\n    \"\"\"\n    Generate a random polynomial with a specified degree, where the constant term is the secret.\n\n    Args:\n        secret (int): The secret to be shared.\n        threshold_degree (int): The degree of the polynomial (k - 1, where k is the threshold).\n        prime (int): A prime number larger than the secret.\n\n    Returns:\n        list: Coefficients of the polynomial [a_0, a_1, ..., a_d].\n    \"\"\"\n    if secret >= prime:\n        raise ValueError(\"Secret must be less than the prime number.\")\n    return [secret] + [randbelow(prime) for _ in range(threshold_degree)]\n\ndef evaluate_polynomial(polynomial, x, prime=DEFAULT_PRIME):\n    \"\"\"\n    Evaluate a polynomial at a given point x using modular arithmetic.\n\n    Args:\n        polynomial (list): Coefficients of the polynomial [a_0, a_1, ..., a_d].\n        x (int): The point at which to evaluate the polynomial.\n        prime (int): A prime number for modular arithmetic.\n\n    Returns:\n        int: The result of the polynomial evaluation mod prime.\n    \"\"\"\n    total = 0\n    for i, coef in enumerate(polynomial):\n        total += coef * pow(x, i, prime)\n        total %= prime\n    return total\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mpc/protocols/ShamirPrep.py b/mpc/protocols/ShamirPrep.py
--- a/mpc/protocols/ShamirPrep.py	(revision 59043ce1d8b682af9354c45934768577c55ae5d8)
+++ b/mpc/protocols/ShamirPrep.py	(date 1733031302710)
@@ -1,6 +1,7 @@
 from secrets import randbelow
 from config.constants import DEFAULT_PRIME, DEFAULT_THRESHOLD_DEGREE
 
+
 def generate_polynomial(secret, threshold_degree=DEFAULT_THRESHOLD_DEGREE, prime=DEFAULT_PRIME):
     """
     Generate a random polynomial with a specified degree, where the constant term is the secret.
@@ -17,6 +18,7 @@
         raise ValueError("Secret must be less than the prime number.")
     return [secret] + [randbelow(prime) for _ in range(threshold_degree)]
 
+
 def evaluate_polynomial(polynomial, x, prime=DEFAULT_PRIME):
     """
     Evaluate a polynomial at a given point x using modular arithmetic.
@@ -30,7 +32,7 @@
         int: The result of the polynomial evaluation mod prime.
     """
     total = 0
-    for i, coef in enumerate(polynomial):
-        total += coef * pow(x, i, prime)
+    for i, coefficient in enumerate(polynomial):
+        total += coefficient * pow(x, i, prime)
         total %= prime
     return total
Index: shamirtest.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from mpc.protocols.ShamirSharing import generate_shares, reconstruct_shares\n\nx = 100\nprime = 2089\nnum_shares = 8\nthreshold_degree = 4\n\nshares = generate_shares(x, num_shares, threshold_degree, prime)\nprint(\"Shares:\", shares)\ncheck = reconstruct_shares(1, shares[:threshold_degree+1], prime)\nprint(\"Check:\", check)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shamirtest.py b/shamirtest.py
--- a/shamirtest.py	(revision 59043ce1d8b682af9354c45934768577c55ae5d8)
+++ b/shamirtest.py	(date 1733031441433)
@@ -7,5 +7,5 @@
 
 shares = generate_shares(x, num_shares, threshold_degree, prime)
 print("Shares:", shares)
-check = reconstruct_shares(1, shares[:threshold_degree+1], prime)
-print("Check:", check)
\ No newline at end of file
+check = reconstruct_shares(shares, shares[:threshold_degree+1])
+print("Check:", check)
Index: mpc/protocols/beavers.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from mpc.utils import generate_secret_shares\nfrom secrets import randbelow\n\ndef beavers_triples(modulus=1000):\n    \"\"\"\n    Generates a Beaver's Triple within the given modulus\n\n    Args:\n        modulus (int): the modulo value to be used\n    \n    Returns:\n        a, b, c: the values of the Beaver\n    \"\"\"\n    a = randbelow(modulus)\n    b = randbelow(modulus)\n    c = (a * b) % modulus\n    return a, b, c\n\ndef share_triples(a, b, c, num_shares, modulus):\n    \"\"\"\n    Shares the Beaver's Triple among the parties\n\n    Args:\n        a, b, c (int): the values of the Beaver\n        num_shares (int): the number of shares to split the secret into\n        modulus (int): the modulo value to be used\n    \n    Returns:\n        a_share, b_share, c_share: the shares of the Beaver\n    \"\"\"\n    a_share = generate_secret_shares(a, num_shares, modulus)\n    b_share = generate_secret_shares(b, num_shares, modulus)\n    c_share = generate_secret_shares(c, num_shares, modulus)\n    return a_share, b_share, c_share\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mpc/protocols/beavers.py b/mpc/protocols/beavers.py
--- a/mpc/protocols/beavers.py	(revision 59043ce1d8b682af9354c45934768577c55ae5d8)
+++ b/mpc/protocols/beavers.py	(date 1733031233510)
@@ -1,6 +1,7 @@
 from mpc.utils import generate_secret_shares
 from secrets import randbelow
 
+
 def beavers_triples(modulus=1000):
     """
     Generates a Beaver's Triple within the given modulus
@@ -16,6 +17,7 @@
     c = (a * b) % modulus
     return a, b, c
 
+
 def share_triples(a, b, c, num_shares, modulus):
     """
     Shares the Beaver's Triple among the parties
@@ -32,4 +34,3 @@
     b_share = generate_secret_shares(b, num_shares, modulus)
     c_share = generate_secret_shares(c, num_shares, modulus)
     return a_share, b_share, c_share
-
Index: config/constants.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\nDEFAULT_MODULUS = 1000\nDEFAULT_NUM_SHARES = 4\n\n# For Shamir Sharing\nDEFAULT_THRESHOLD_DEGREE = 2\nDEFAULT_PRIME = 2087\nPRIME_NUMBERS = [1013, 2087,3517]
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/config/constants.py b/config/constants.py
--- a/config/constants.py	(revision 59043ce1d8b682af9354c45934768577c55ae5d8)
+++ b/config/constants.py	(date 1733031302720)
@@ -1,8 +1,7 @@
-
 DEFAULT_MODULUS = 1000
 DEFAULT_NUM_SHARES = 4
 
 # For Shamir Sharing
 DEFAULT_THRESHOLD_DEGREE = 2
 DEFAULT_PRIME = 2087
-PRIME_NUMBERS = [1013, 2087,3517]
\ No newline at end of file
+PRIME_NUMBERS = [1013, 2087, 3517]
Index: mpc/utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import Tuple\nfrom mpc.party import Party\nimport secrets\n\n\ndef sum_of_values(client_values):\n    return sum(client_values)\n\n\ndef generate_secret_shares(secret, num_shares=3, modulus=1000) -> Tuple[int]:\n    '''\n    Generate secret shares of a number into num_shares within the modulus\n\n    Args:\n        secret (int): the secret to be shared\n        num_shares (int): the number of shares to split the secret into\n        modulus (int): the modulo value to be used\n    \n    Returns:\n        List[int]: the secret shares [s1, s2, ..., sn]\n    '''\n    partial_shares = [secrets.randbelow(modulus) for _ in range(num_shares - 1)]\n    last_share = (secret - sum(partial_shares)) % modulus\n    return partial_shares + [last_share]\n\n\ndef reconstruct_value(shares, modulu=1000):\n    '''\n    Reconstruct the secret from the shares with the given modulu\n\n    Args:\n        shares (List[int]): the shares to be reconstructed\n        modulu (int): the modulo value to be used\n    \n    Returns:\n        int: the reconstructed secret [sigma(si) % modulu]\n    '''\n    return sum(shares) % modulu\n\n\ndef create_parites(client_shares, modulo=1000):\n    '''\n    Creates a list of parties from the client shares with the given modulo\n\n    Args:\n        client_shares (List[int]): the shares to be used to create the parties\n        modulo (int): the modulo value to be used\n\n    Returns:\n        List[Party]: the list of parties (Each party is an instance of the Party class)\n    '''\n    parties = []\n    for client_share in client_shares:\n        parties.append(Party(client_share, modulo))\n    return parties
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mpc/utils.py b/mpc/utils.py
--- a/mpc/utils.py	(revision 59043ce1d8b682af9354c45934768577c55ae5d8)
+++ b/mpc/utils.py	(date 1733031212663)
@@ -8,38 +8,38 @@
 
 
 def generate_secret_shares(secret, num_shares=3, modulus=1000) -> Tuple[int]:
-    '''
+    """
     Generate secret shares of a number into num_shares within the modulus
 
     Args:
         secret (int): the secret to be shared
         num_shares (int): the number of shares to split the secret into
         modulus (int): the modulo value to be used
-    
+
     Returns:
         List[int]: the secret shares [s1, s2, ..., sn]
-    '''
+    """
     partial_shares = [secrets.randbelow(modulus) for _ in range(num_shares - 1)]
     last_share = (secret - sum(partial_shares)) % modulus
     return partial_shares + [last_share]
 
 
-def reconstruct_value(shares, modulu=1000):
-    '''
-    Reconstruct the secret from the shares with the given modulu
+def reconstruct_value(shares, modulus=1000):
+    """
+    Reconstruct the secret from the shares with the given modulus
 
     Args:
         shares (List[int]): the shares to be reconstructed
-        modulu (int): the modulo value to be used
-    
+        modulus (int): the modulo value to be used
+
     Returns:
-        int: the reconstructed secret [sigma(si) % modulu]
-    '''
-    return sum(shares) % modulu
+        int: the reconstructed secret [sigma(si) % modulus
+    """
+    return sum(shares) % modulus
 
 
-def create_parites(client_shares, modulo=1000):
-    '''
+def create_parties(client_shares, modulo=1000):
+    """
     Creates a list of parties from the client shares with the given modulo
 
     Args:
@@ -48,8 +48,8 @@
 
     Returns:
         List[Party]: the list of parties (Each party is an instance of the Party class)
-    '''
+    """
     parties = []
     for client_share in client_shares:
         parties.append(Party(client_share, modulo))
-    return parties
\ No newline at end of file
+    return parties
