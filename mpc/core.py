from typing import List
from mpc.party import Party, BeaverParty
class MPC:
    '''
    MPC class represents the Multi-Party Computation protocol.
    base class for all the MPC operations
    
    attributes:
        parties: list of parties in the computation

    methods:
        get_party(index): returns the party at the given index
    '''
    def __init__(self, parties: List[Party] | List[BeaverParty]) -> None:
        self.parties = parties
    
    def get_party(self, index):
        return self.parties[index]

class MPCAddition(MPC):
    '''
    Inherited MPC class for the addition operation
    Gets a list of parties and computes the sum of the partial sums generated by each party

    methods:
        compute(): computes the sum of the shares
    '''
    def compute(self) -> int:
        total_sum = sum([party.compute_partial_sum() for party in self.parties])

        return total_sum % self.parties[-1].modulo
 

class MPCAverage(MPCAddition):
    def compute(self) -> int:
        return super().compute() / len(self.parties)

 
class MPCMultiplication(MPC):
    '''
    Inherited MPC class for the multiplication operation using Beaver's Triple
    Each party computes the partial product of the shares and the final product is computed by summing the partial products
    x*y = c + e*b + f*a + [e*f] where [] is computed by only one party

    a, b, c are the shares of the Beaver's Triple
    e,f are the partial values computed by each party [e = x - a, f = y - b]

    Attributes:
        e: partial value e
        f: partial value f
        product_shares: list of partial products computed by each party

    Methods:
        compute_ef_shares(): computes the partial values e and f (private method)
        compute(): computes the product of the shares

    '''
    def __init__(self, parties: List[BeaverParty]) -> None:
        super().__init__(parties)
        self.e, self.f = None, None
        self.product_shares = []

    def compute_ef_shares(self) -> int:
        e_shares, f_shares = [], []
        for i, party in enumerate(self.parties):
            e, f = party.compute_partial_e_f()
            e_shares.append(e)
            f_shares.append(f)

        self.e = sum(e_shares) % self.parties[-1].modulo
        self.f = sum(f_shares) % self.parties[-1].modulo

    def compute(self):
        """
        Computes the product of the shares using Beaver's Triple
        x*y = c + e*b + f*a + [e*f]
        sums the partial products computed by each party and last party computes the final product

        Returns:
            Int: the final product of the shares [x*y]
        """
        self.compute_ef_shares()
        for party in self.parties:
            product = party.compute_partial_product(self.e, self.f)
            self.product_shares.append(product)  
        
        final_product = sum(self.product_shares)
        final_product = (final_product + (self.e * self.f)) % self.parties[-1].modulo

        return final_product

